/**
 * @author Ikaros Kappler
 * @date 2014-05-09
 * @version 1.0.0
 **/



IKRS.RegexParser = function( tokenizer ) {

    IKRS.Object.call( this );
    
    this.tokenizer      = tokenizer;    
    this.stack          = [];
    this.currentRegex   = null;
};

IKRS.RegexParser.prototype.read = function() {
    // Invariant: on each reading function call the tokenizer 
    //            points onto the _current_ token!
    // So read the first one.
    this.tokenizer.nextToken();
    // Then parse the first regex.
    this.currentRegex = this._readRegex();
    return this._read();
};

IKRS.RegexParser.prototype._read = function() {

    //if( !this.tokenizer.reachedEOI() && this.tokenizer.currentToken.isClosingBracketOperator() )
//	return this.currentToken;
    
    var i = 0;
    //do {
    var bracketCounter = 0;
    var lastRegex      = this.currentRegex;
    while( !this.tokenizer.reachedEOI() ) { //currentToken != null ) { 
	
	if( this.tokenizer.currentToken.isOpeningBracketOperator() )
	    bracketCounter++;

	// Remember: on the very first run (first function call, first loop)
	// the currentRegex is null!
	var last = this.currentRegex;

	window.alert( "Next token afert regex '" + last + "': " + this.currentToken );

	var next = this._readRegex();
	
	window.alert( "next_node: " + next );
	
	
	if( !this.tokenizer.reachedEOI() && this.tokenizer.currentToken.isClosingBracketOperator() ) {

	    if( bracketCounter == 0 ) {
		if( this.tokenizer.nextToken() != null )
		    ; //return this._read(); // this.currentRegex;
		else
		    return this.currentRegex;
	    }

	    bracketCounter--;
	}
	
	i++;

    } 

    return this.currentRegex; 
}


IKRS.RegexParser.prototype._readRegex = function() {

    if( this.tokenizer.currentToken == null )
	return null;  // EOI

    
    if( this.tokenizer.currentToken.isConstant ) {	
	return this._readConstant( true );  // Allow '-' here

    } else if( this.tokenizer.currentToken.isOperator ) {
	
	if( this.tokenizer.currentToken.value == "*" ) { 

	    return this._readKleene( false ); // notEmpty = false;
	    
	} else if( this.tokenizer.currentToken.value == "+" ) { 
	    
	    return this._readKleene( true );  // notEmpty = true

	} else if( this.tokenizer.currentToken.value == "(" ) { 

	    return this._readComposite();

	} else if( this.tokenizer.currentToken.value == ')' ) {
	    
	    return this.currentRegex;

	} else if( this.tokenizer.currentToken.value == "[" ) { 
	    
	    return this._readCharacterSet();

	} else if( this.tokenizer.currentToken.value == "|" ) {
	    
	    return this._readUnion();
	    
	} else {
	    throw "Unexpected operator: " + this.tokenizer.currentToken.rawValue + " (" + this.tokenizer.currentToken.value + ").";
	}

    } else {

	throw "Symbol " + this.tokenizer.currentToken.rawValue + " is not an operator nor a constant value.";

    }

};

IKRS.RegexParser.prototype._readKleene = function( notEmpty ) {
 
    var lastRegex = this.currentRegex; // this.stack.pop();
    var newRegex  = new IKRS.RegexKleene( lastRegex, 
					  (notEmpty ? 1 : 0),  // At least once?
					  -1                   // No upper bound
					);
    this.tokenizer.nextToken();
    this.currentRegex = newRegex;
    return newRegex;
};

IKRS.RegexParser.prototype._readComposite = function() {
    
    //throw "Composite '(' operator not yet supported.";
    //window.alert( "COMPOSITE STARTS AT position: " + this.tokenizer.pushbackReader.position );
    // Skip from '(' to next token
    this.tokenizer.nextToken();
    
    /*while( this.tokenizer.currentToken != null &&
	   ( !this.tokenizer.currentToken.isOperator ||
	     this.tokenizer.currentToken.value != ')' 
	   )
	 ) {*/
    while( !this.tokenizer.reachedEOI() && 
	   !this.tokenizer.currentToken.isClosingBracketOperator() 
	 ) {

	//var last = this.currentRegex;
	var next = this._read();
	
	//if( last != null && next != null )
	//    this.currentRegex = new IKRS.RegexConcatenation( last, next );
	//window.alert( "Composite: " + this.currentRegex );
	
    }
    
    if( this.tokenizer.reachedEOI() )
	throw "EOI reached where ')' is expected.";

    if( !this.tokenizer.currentToken.isClosingBracketOperator() ) 
	throw "Unexpected token '" + this.tokenizer.currentToken.value + "' where operator ')' is expected.";
    
    //this.tokenizer.nextToken(); 
    
    return this.currentRegex;
};

IKRS.RegexParser.prototype._readCharacterSet = function() {
    throw "Character set '[' operator not yet supported.";
};

IKRS.RegexParser.prototype._readUnion = function() {

    // The current token is '|'.
    // So switch to the next token, then read the next regex, then 
    // construct a UNION regex.  
    if( this.tokenizer.nextToken() == null )
	throw "Unexpected EOI after union operator '|'.";

    // Take the last regex
    var lastRegex = this.currentRegex;
    // Parse the next regex
    var nextRegex = this._read(); //this._readRegex();

    var union = new IKRS.RegexUnion(lastRegex,nextRegex);
    this.currentRegex = union;

    return union;
};

IKRS.RegexParser.prototype._readConstant = function( allowDashAsConstant ) {
    
    //window.alert( "BEGIN_OF_CONSTANT=" + this.tokenizer.currentToken.value );

    // Append the current token.
    // It already belongs to the constant (first character).
    var stringBuffer = new IKRS.StringBuffer( this.tokenizer.currentToken.value );
    while( this.tokenizer.nextToken() != null &&
	   this.tokenizer.currentToken.isConstant && 
	   (allowDashAsConstant || this.tokenizer.currentToken.value != '-') 
	 ) {

	stringBuffer.append( this.tokenizer.currentToken.value  );
    };
	   
    this.currentRegex = new IKRS.RegexConstant(stringBuffer.toString());

    // Note that the STERN operators bind STRONGER than any other operator!
    while( this.tokenizer.currentToken != null &&
	   this.tokenizer.currentToken.isOperator &&
	   this.tokenizer.currentToken.isSternOperator() ) {
	//window.alert( "is STERN (base=" + this.currentRegex + ")");

	this._read(); // this._readRegex();
    }

    return this.currentRegex;
};



IKRS.RegexParser.prototype.constructor = IKRS.RegexParser;
